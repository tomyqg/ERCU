/*
*********************************************************************************************************
*                                               uC/OS-II
*                                         The Real-Time Kernel
*
*                         (c) Copyright 2002, Jean J. Labrosse, Weston, FL
*                                          All Rights Reserved
*
*
*                                          68HC12 Specific code
*                                                  IAR
*
* File         : OS_CPU.H
* By           : Jean J. Labrosse
* 修改         : 飞思卡尔社区-hairong 
* Port Version : V2.00 (for uC/OS-II V2.61 and higher)
*********************************************************************************************************
*/

#ifndef __OS_CPU_H__
#define	__OS_CPU_H__

/*
*********************************************************************************************************
*                                              DATA TYPES
*********************************************************************************************************
*/

typedef unsigned char  BOOLEAN;
typedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
typedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
typedef unsigned int   INT16U;                   /* Unsigned 16 bit quantity                           */
typedef signed   int   INT16S;                   /* Signed   16 bit quantity                           */
typedef unsigned long  INT32U;                   /* Unsigned 32 bit quantity                           */
typedef signed   long  INT32S;                   /* Signed   32 bit quantity                           */
typedef float          FP32;                     /* Single precision floating point                    */
typedef double         FP64;                     /* Double precision floating point                    */

//#define BYTE           INT8S                     /* Define data types for backward compatibility ...   */
//#define UBYTE          INT8U                     /* ... to uC/OS V1.xx                                 */
/*#define WORD           INT16S
#define UWORD          INT16U
#define LONG           INT32S
#define ULONG          INT32U */

typedef unsigned char  OS_STK;                   /* Each stack entry is 8-bit wide                     */
typedef unsigned char  OS_CPU_SR;                /* Define size of CPU status register (PSW = 16 bits) */

/*
*********************************************************************************************************
*                                              CONSTANTS
*********************************************************************************************************
*/

#ifndef  FALSE
#define  FALSE    0
#endif

#ifndef  TRUE
#define  TRUE     1
#endif

/* 
*********************************************************************************************************
*                                           Motorola 68HC12
*
* Method #1:  Disable/Enable interrupts using simple instructions.  After critical section, interrupts
*             will be enabled even if they were disabled before entering the critical section.
*
* Method #2:  Disable/Enable interrupts by preserving the state of interrupts.  In other words, if 
*             interrupts were disabled before entering the critical section, they will be disabled when
*             leaving the critical section.
*
* Method #3:  Disable/Enable interrupts by preserving the state of interrupts.  Generally speaking you
*             would store the state of the interrupt disable flag in the local variable 'cpu_sr' and then
*             disable interrupts.  'cpu_sr' is allocated in all of uC/OS-II's functions that need to 
*             disable interrupts.  You would restore the interrupt disable state by copying back 'cpu_sr'
*             into the CPU's status register.
*
* NOTE(s)  :  1) The current version of the compiler does NOT allow method #2 to be used without changing
*                the processor independent portion of uC/OS-II.
*             2) The current version of the compiler does NOT allow method #3 either.  However, this can
*                be implemented in OS_CPU_A.S by defining the functions: OSCPUSaveSR() and 
*                OSCPURestoreSR().
*********************************************************************************************************
*/

#define  OS_CRITICAL_METHOD   3

#if      OS_CRITICAL_METHOD == 1
#define  OS_ENTER_CRITICAL()  __asm sei							                /* Disable interrupts              */
#define  OS_EXIT_CRITICAL()   __asm cli					                    /* Enable  interrupts              */
#endif

#if      OS_CRITICAL_METHOD == 2
#define  OS_ENTER_CRITICAL()  __asm (pshc; sei)					            /* Disable interrupts              */
#define  OS_EXIT_CRITICAL()   __asm (pulc)				                  /* Enable  interrupts              */
#endif

#if      OS_CRITICAL_METHOD == 3
#define  OS_ENTER_CRITICAL()  __asm (tpa; sei; staa cpu_sr;)	        /* Disable interrupts              */
#define  OS_EXIT_CRITICAL()   __asm (ldaa cpu_sr; tap;)	            /* Enable  interrupts              */
#endif


/*#if      OS_CRITICAL_METHOD == 3
#define  OS_ENTER_CRITICAL()  {asm tpa; asm sei; asm staa cpu_sr;}	        
#define  OS_EXIT_CRITICAL()   {asm ldaa cpu_sr; asm tap}
#endif */



#define  OS_TASK_SW()         asm "jsr OSCtxSw"
					 	   
#define  OS_STK_GROWTH        1                                     /* Stack growth: 1 = Down, 0 = Up */

#define  OS_SAVE_SP()         if (OSIntNesting==1){__asm (ldx OSTCBCur; sts 0,x);}

void          OSStartHighRdy        (void);
void          OSIntCtxSw            (void);
void          OSCtxSw               (void);                    

#endif	
